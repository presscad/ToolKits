/* soapStub.h
   Generated by gSOAP 2.8.19 from d:\Structure\!ClientServTemp\ClientServer.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_TMSServ	"http://xerofox.com/TMSService/"
#define SOAP_NAMESPACE_OF_VersionServ	"http://xerofox.com/VersionService/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20819
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (7)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_TMSServ__ArrayOfInt
#define SOAP_TYPE_TMSServ__ArrayOfInt (12)
/* TMSServ:ArrayOfInt */
class SOAP_CMAC TMSServ__ArrayOfInt
{
public:
	int __sizeint_;	/* sequence of elements <int> */
	int *int_;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE_TMSServ__ArrayOfInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         TMSServ__ArrayOfInt() { TMSServ__ArrayOfInt::soap_default(NULL); }
	virtual ~TMSServ__ArrayOfInt() { }
};
#endif

#ifndef SOAP_TYPE_TMSServ__ArrayOfUnsignedInt
#define SOAP_TYPE_TMSServ__ArrayOfUnsignedInt (13)
/* TMSServ:ArrayOfUnsignedInt */
class SOAP_CMAC TMSServ__ArrayOfUnsignedInt
{
public:
	int __sizeunsignedInt;	/* sequence of elements <unsignedInt> */
	unsigned int *unsignedInt;	/* optional element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique type id SOAP_TYPE_TMSServ__ArrayOfUnsignedInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         TMSServ__ArrayOfUnsignedInt() { TMSServ__ArrayOfUnsignedInt::soap_default(NULL); }
	virtual ~TMSServ__ArrayOfUnsignedInt() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__loginUser
#define SOAP_TYPE__TMSServ__loginUser (14)
/* TMSServ:loginUser */
class SOAP_CMAC _TMSServ__loginUser
{
public:
	char *userName;	/* optional element of type xsd:string */
	char *password;	/* optional element of type xsd:string */
	char *fingerprint;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE__TMSServ__loginUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__loginUser() { _TMSServ__loginUser::soap_default(NULL); }
	virtual ~_TMSServ__loginUser() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__loginUserResponse
#define SOAP_TYPE__TMSServ__loginUserResponse (15)
/* TMSServ:loginUserResponse */
class SOAP_CMAC _TMSServ__loginUserResponse
{
public:
	int loginUserResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE__TMSServ__loginUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__loginUserResponse() { _TMSServ__loginUserResponse::soap_default(NULL); }
	virtual ~_TMSServ__loginUserResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__loginUserByByteArr
#define SOAP_TYPE__TMSServ__loginUserByByteArr (16)
/* TMSServ:loginUserByByteArr */
class SOAP_CMAC _TMSServ__loginUserByByteArr
{
public:
	xsd__base64Binary *userInfo;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE__TMSServ__loginUserByByteArr */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__loginUserByByteArr() { _TMSServ__loginUserByByteArr::soap_default(NULL); }
	virtual ~_TMSServ__loginUserByByteArr() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__loginUserByByteArrResponse
#define SOAP_TYPE__TMSServ__loginUserByByteArrResponse (17)
/* TMSServ:loginUserByByteArrResponse */
class SOAP_CMAC _TMSServ__loginUserByByteArrResponse
{
public:
	int loginUserByByteArrResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE__TMSServ__loginUserByByteArrResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__loginUserByByteArrResponse() { _TMSServ__loginUserByByteArrResponse::soap_default(NULL); }
	virtual ~_TMSServ__loginUserByByteArrResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__logoutUser
#define SOAP_TYPE__TMSServ__logoutUser (18)
/* TMSServ:logoutUser */
class SOAP_CMAC _TMSServ__logoutUser
{
public:
	int sessionId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE__TMSServ__logoutUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__logoutUser() { _TMSServ__logoutUser::soap_default(NULL); }
	virtual ~_TMSServ__logoutUser() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__logoutUserResponse
#define SOAP_TYPE__TMSServ__logoutUserResponse (19)
/* TMSServ:logoutUserResponse */
class SOAP_CMAC _TMSServ__logoutUserResponse
{
public:
	int logoutUserResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE__TMSServ__logoutUserResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__logoutUserResponse() { _TMSServ__logoutUserResponse::soap_default(NULL); }
	virtual ~_TMSServ__logoutUserResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__QueryObjects
#define SOAP_TYPE__TMSServ__QueryObjects (20)
/* TMSServ:QueryObjects */
class SOAP_CMAC _TMSServ__QueryObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	char *xmlScope;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE__TMSServ__QueryObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__QueryObjects() { _TMSServ__QueryObjects::soap_default(NULL); }
	virtual ~_TMSServ__QueryObjects() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__QueryObjectsResponse
#define SOAP_TYPE__TMSServ__QueryObjectsResponse (21)
/* TMSServ:QueryObjectsResponse */
class SOAP_CMAC _TMSServ__QueryObjectsResponse
{
public:
	xsd__base64Binary *QueryObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE__TMSServ__QueryObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__QueryObjectsResponse() { _TMSServ__QueryObjectsResponse::soap_default(NULL); }
	virtual ~_TMSServ__QueryObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DownloadObjects
#define SOAP_TYPE__TMSServ__DownloadObjects (22)
/* TMSServ:DownloadObjects */
class SOAP_CMAC _TMSServ__DownloadObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	TMSServ__ArrayOfInt *idarr;	/* optional element of type TMSServ:ArrayOfInt */
	unsigned int serialize;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE__TMSServ__DownloadObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DownloadObjects() { _TMSServ__DownloadObjects::soap_default(NULL); }
	virtual ~_TMSServ__DownloadObjects() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DownloadObjectsResponse
#define SOAP_TYPE__TMSServ__DownloadObjectsResponse (23)
/* TMSServ:DownloadObjectsResponse */
class SOAP_CMAC _TMSServ__DownloadObjectsResponse
{
public:
	xsd__base64Binary *DownloadObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE__TMSServ__DownloadObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DownloadObjectsResponse() { _TMSServ__DownloadObjectsResponse::soap_default(NULL); }
	virtual ~_TMSServ__DownloadObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__GetObjectsVersion
#define SOAP_TYPE__TMSServ__GetObjectsVersion (24)
/* TMSServ:GetObjectsVersion */
class SOAP_CMAC _TMSServ__GetObjectsVersion
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	TMSServ__ArrayOfInt *idarr;	/* optional element of type TMSServ:ArrayOfInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE__TMSServ__GetObjectsVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__GetObjectsVersion() { _TMSServ__GetObjectsVersion::soap_default(NULL); }
	virtual ~_TMSServ__GetObjectsVersion() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__GetObjectsVersionResponse
#define SOAP_TYPE__TMSServ__GetObjectsVersionResponse (25)
/* TMSServ:GetObjectsVersionResponse */
class SOAP_CMAC _TMSServ__GetObjectsVersionResponse
{
public:
	TMSServ__ArrayOfUnsignedInt *GetObjectsVersionResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type TMSServ:ArrayOfUnsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE__TMSServ__GetObjectsVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__GetObjectsVersionResponse() { _TMSServ__GetObjectsVersionResponse::soap_default(NULL); }
	virtual ~_TMSServ__GetObjectsVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__GetTowerPartsLabelAndVersionSerial
#define SOAP_TYPE__TMSServ__GetTowerPartsLabelAndVersionSerial (26)
/* TMSServ:GetTowerPartsLabelAndVersionSerial */
class SOAP_CMAC _TMSServ__GetTowerPartsLabelAndVersionSerial
{
public:
	int sessionId;	/* required element of type xsd:int */
	int towerTypeId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE__TMSServ__GetTowerPartsLabelAndVersionSerial */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__GetTowerPartsLabelAndVersionSerial() { _TMSServ__GetTowerPartsLabelAndVersionSerial::soap_default(NULL); }
	virtual ~_TMSServ__GetTowerPartsLabelAndVersionSerial() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__GetTowerPartsLabelAndVersionSerialResponse
#define SOAP_TYPE__TMSServ__GetTowerPartsLabelAndVersionSerialResponse (27)
/* TMSServ:GetTowerPartsLabelAndVersionSerialResponse */
class SOAP_CMAC _TMSServ__GetTowerPartsLabelAndVersionSerialResponse
{
public:
	xsd__base64Binary *GetTowerPartsLabelAndVersionSerialResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE__TMSServ__GetTowerPartsLabelAndVersionSerialResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__GetTowerPartsLabelAndVersionSerialResponse() { _TMSServ__GetTowerPartsLabelAndVersionSerialResponse::soap_default(NULL); }
	virtual ~_TMSServ__GetTowerPartsLabelAndVersionSerialResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__MatchTowerParts
#define SOAP_TYPE__TMSServ__MatchTowerParts (28)
/* TMSServ:MatchTowerParts */
class SOAP_CMAC _TMSServ__MatchTowerParts
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *xmlformat;	/* optional element of type xsd:string */
	xsd__base64Binary *byteArr;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE__TMSServ__MatchTowerParts */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__MatchTowerParts() { _TMSServ__MatchTowerParts::soap_default(NULL); }
	virtual ~_TMSServ__MatchTowerParts() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__MatchTowerPartsResponse
#define SOAP_TYPE__TMSServ__MatchTowerPartsResponse (29)
/* TMSServ:MatchTowerPartsResponse */
class SOAP_CMAC _TMSServ__MatchTowerPartsResponse
{
public:
	char *MatchTowerPartsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE__TMSServ__MatchTowerPartsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__MatchTowerPartsResponse() { _TMSServ__MatchTowerPartsResponse::soap_default(NULL); }
	virtual ~_TMSServ__MatchTowerPartsResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__SaveOrUpdateObjects
#define SOAP_TYPE__TMSServ__SaveOrUpdateObjects (30)
/* TMSServ:SaveOrUpdateObjects */
class SOAP_CMAC _TMSServ__SaveOrUpdateObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	char *xmlformat;	/* optional element of type xsd:string */
	xsd__base64Binary *byteArr;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE__TMSServ__SaveOrUpdateObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__SaveOrUpdateObjects() { _TMSServ__SaveOrUpdateObjects::soap_default(NULL); }
	virtual ~_TMSServ__SaveOrUpdateObjects() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__SaveOrUpdateObjectsResponse
#define SOAP_TYPE__TMSServ__SaveOrUpdateObjectsResponse (31)
/* TMSServ:SaveOrUpdateObjectsResponse */
class SOAP_CMAC _TMSServ__SaveOrUpdateObjectsResponse
{
public:
	char *SaveOrUpdateObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE__TMSServ__SaveOrUpdateObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__SaveOrUpdateObjectsResponse() { _TMSServ__SaveOrUpdateObjectsResponse::soap_default(NULL); }
	virtual ~_TMSServ__SaveOrUpdateObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DeleteObject
#define SOAP_TYPE__TMSServ__DeleteObject (32)
/* TMSServ:DeleteObject */
class SOAP_CMAC _TMSServ__DeleteObject
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	int objId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE__TMSServ__DeleteObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DeleteObject() { _TMSServ__DeleteObject::soap_default(NULL); }
	virtual ~_TMSServ__DeleteObject() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DeleteObjectResponse
#define SOAP_TYPE__TMSServ__DeleteObjectResponse (33)
/* TMSServ:DeleteObjectResponse */
class SOAP_CMAC _TMSServ__DeleteObjectResponse
{
public:
	bool DeleteObjectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE__TMSServ__DeleteObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DeleteObjectResponse() { _TMSServ__DeleteObjectResponse::soap_default(NULL); }
	virtual ~_TMSServ__DeleteObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DownloadFileById
#define SOAP_TYPE__TMSServ__DownloadFileById (34)
/* TMSServ:DownloadFileById */
class SOAP_CMAC _TMSServ__DownloadFileById
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	int fileId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE__TMSServ__DownloadFileById */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DownloadFileById() { _TMSServ__DownloadFileById::soap_default(NULL); }
	virtual ~_TMSServ__DownloadFileById() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DownloadFileByIdResponse
#define SOAP_TYPE__TMSServ__DownloadFileByIdResponse (35)
/* TMSServ:DownloadFileByIdResponse */
class SOAP_CMAC _TMSServ__DownloadFileByIdResponse
{
public:
	xsd__base64Binary *DownloadFileByIdResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE__TMSServ__DownloadFileByIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DownloadFileByIdResponse() { _TMSServ__DownloadFileByIdResponse::soap_default(NULL); }
	virtual ~_TMSServ__DownloadFileByIdResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__UploadFileObject
#define SOAP_TYPE__TMSServ__UploadFileObject (36)
/* TMSServ:UploadFileObject */
class SOAP_CMAC _TMSServ__UploadFileObject
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idFileObj;	/* required element of type xsd:int */
	int startposition;	/* required element of type xsd:int */
	xsd__base64Binary *byteArr;	/* optional element of type xsd:base64Binary */
	bool compressed;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE__TMSServ__UploadFileObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__UploadFileObject() { _TMSServ__UploadFileObject::soap_default(NULL); }
	virtual ~_TMSServ__UploadFileObject() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__UploadFileObjectResponse
#define SOAP_TYPE__TMSServ__UploadFileObjectResponse (37)
/* TMSServ:UploadFileObjectResponse */
class SOAP_CMAC _TMSServ__UploadFileObjectResponse
{
public:
	bool UploadFileObjectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE__TMSServ__UploadFileObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__UploadFileObjectResponse() { _TMSServ__UploadFileObjectResponse::soap_default(NULL); }
	virtual ~_TMSServ__UploadFileObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__FinalizeFileObjectData
#define SOAP_TYPE__TMSServ__FinalizeFileObjectData (38)
/* TMSServ:FinalizeFileObjectData */
class SOAP_CMAC _TMSServ__FinalizeFileObjectData
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idFileObj;	/* required element of type xsd:int */
	int file_USCORElength;	/* required element of type xsd:int */
	bool isOverriteFile;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE__TMSServ__FinalizeFileObjectData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__FinalizeFileObjectData() { _TMSServ__FinalizeFileObjectData::soap_default(NULL); }
	virtual ~_TMSServ__FinalizeFileObjectData() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__FinalizeFileObjectDataResponse
#define SOAP_TYPE__TMSServ__FinalizeFileObjectDataResponse (39)
/* TMSServ:FinalizeFileObjectDataResponse */
class SOAP_CMAC _TMSServ__FinalizeFileObjectDataResponse
{
public:
	char *FinalizeFileObjectDataResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE__TMSServ__FinalizeFileObjectDataResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__FinalizeFileObjectDataResponse() { _TMSServ__FinalizeFileObjectDataResponse::soap_default(NULL); }
	virtual ~_TMSServ__FinalizeFileObjectDataResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__OpenFileObjectDataProvider
#define SOAP_TYPE__TMSServ__OpenFileObjectDataProvider (40)
/* TMSServ:OpenFileObjectDataProvider */
class SOAP_CMAC _TMSServ__OpenFileObjectDataProvider
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idFileObj;	/* required element of type xsd:int */
	bool compressed;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE__TMSServ__OpenFileObjectDataProvider */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__OpenFileObjectDataProvider() { _TMSServ__OpenFileObjectDataProvider::soap_default(NULL); }
	virtual ~_TMSServ__OpenFileObjectDataProvider() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__OpenFileObjectDataProviderResponse
#define SOAP_TYPE__TMSServ__OpenFileObjectDataProviderResponse (41)
/* TMSServ:OpenFileObjectDataProviderResponse */
class SOAP_CMAC _TMSServ__OpenFileObjectDataProviderResponse
{
public:
	unsigned int OpenFileObjectDataProviderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE__TMSServ__OpenFileObjectDataProviderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__OpenFileObjectDataProviderResponse() { _TMSServ__OpenFileObjectDataProviderResponse::soap_default(NULL); }
	virtual ~_TMSServ__OpenFileObjectDataProviderResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__OpenTapModelDataProvider
#define SOAP_TYPE__TMSServ__OpenTapModelDataProvider (42)
/* TMSServ:OpenTapModelDataProvider */
class SOAP_CMAC _TMSServ__OpenTapModelDataProvider
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idTowerType;	/* required element of type xsd:int */
	bool compressed;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE__TMSServ__OpenTapModelDataProvider */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__OpenTapModelDataProvider() { _TMSServ__OpenTapModelDataProvider::soap_default(NULL); }
	virtual ~_TMSServ__OpenTapModelDataProvider() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__OpenTapModelDataProviderResponse
#define SOAP_TYPE__TMSServ__OpenTapModelDataProviderResponse (43)
/* TMSServ:OpenTapModelDataProviderResponse */
class SOAP_CMAC _TMSServ__OpenTapModelDataProviderResponse
{
public:
	char *OpenTapModelDataProviderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE__TMSServ__OpenTapModelDataProviderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__OpenTapModelDataProviderResponse() { _TMSServ__OpenTapModelDataProviderResponse::soap_default(NULL); }
	virtual ~_TMSServ__OpenTapModelDataProviderResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__OpenServerObjectDataProvider
#define SOAP_TYPE__TMSServ__OpenServerObjectDataProvider (44)
/* TMSServ:OpenServerObjectDataProvider */
class SOAP_CMAC _TMSServ__OpenServerObjectDataProvider
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idObject;	/* required element of type xsd:int */
	char *cls_USCOREname;	/* optional element of type xsd:string */
	bool compressed;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE__TMSServ__OpenServerObjectDataProvider */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__OpenServerObjectDataProvider() { _TMSServ__OpenServerObjectDataProvider::soap_default(NULL); }
	virtual ~_TMSServ__OpenServerObjectDataProvider() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__OpenServerObjectDataProviderResponse
#define SOAP_TYPE__TMSServ__OpenServerObjectDataProviderResponse (45)
/* TMSServ:OpenServerObjectDataProviderResponse */
class SOAP_CMAC _TMSServ__OpenServerObjectDataProviderResponse
{
public:
	char *OpenServerObjectDataProviderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE__TMSServ__OpenServerObjectDataProviderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__OpenServerObjectDataProviderResponse() { _TMSServ__OpenServerObjectDataProviderResponse::soap_default(NULL); }
	virtual ~_TMSServ__OpenServerObjectDataProviderResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DownloadFileObject
#define SOAP_TYPE__TMSServ__DownloadFileObject (46)
/* TMSServ:DownloadFileObject */
class SOAP_CMAC _TMSServ__DownloadFileObject
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idFileObj;	/* required element of type xsd:int */
	int startposition;	/* required element of type xsd:int */
	int download_USCOREsize;	/* required element of type xsd:int */
	bool compressed;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE__TMSServ__DownloadFileObject */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DownloadFileObject() { _TMSServ__DownloadFileObject::soap_default(NULL); }
	virtual ~_TMSServ__DownloadFileObject() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__DownloadFileObjectResponse
#define SOAP_TYPE__TMSServ__DownloadFileObjectResponse (47)
/* TMSServ:DownloadFileObjectResponse */
class SOAP_CMAC _TMSServ__DownloadFileObjectResponse
{
public:
	xsd__base64Binary *DownloadFileObjectResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE__TMSServ__DownloadFileObjectResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__DownloadFileObjectResponse() { _TMSServ__DownloadFileObjectResponse::soap_default(NULL); }
	virtual ~_TMSServ__DownloadFileObjectResponse() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__CloseFileObjectDataProvider
#define SOAP_TYPE__TMSServ__CloseFileObjectDataProvider (48)
/* TMSServ:CloseFileObjectDataProvider */
class SOAP_CMAC _TMSServ__CloseFileObjectDataProvider
{
public:
	int sessionId;	/* required element of type xsd:int */
	int idFileObj;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE__TMSServ__CloseFileObjectDataProvider */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__CloseFileObjectDataProvider() { _TMSServ__CloseFileObjectDataProvider::soap_default(NULL); }
	virtual ~_TMSServ__CloseFileObjectDataProvider() { }
};
#endif

#ifndef SOAP_TYPE__TMSServ__CloseFileObjectDataProviderResponse
#define SOAP_TYPE__TMSServ__CloseFileObjectDataProviderResponse (49)
/* TMSServ:CloseFileObjectDataProviderResponse */
class SOAP_CMAC _TMSServ__CloseFileObjectDataProviderResponse
{
public:
	bool CloseFileObjectDataProviderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE__TMSServ__CloseFileObjectDataProviderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _TMSServ__CloseFileObjectDataProviderResponse() { _TMSServ__CloseFileObjectDataProviderResponse::soap_default(NULL); }
	virtual ~_TMSServ__CloseFileObjectDataProviderResponse() { }
};
#endif

#ifndef SOAP_TYPE___TMSServ2__loginUser
#define SOAP_TYPE___TMSServ2__loginUser (59)
/* Operation wrapper: */
struct __TMSServ2__loginUser
{
public:
	_TMSServ__loginUser *TMSServ__loginUser;	/* optional element of type TMSServ:loginUser */
public:
	int soap_type() const { return 59; } /* = unique type id SOAP_TYPE___TMSServ2__loginUser */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__loginUserByByteArr
#define SOAP_TYPE___TMSServ2__loginUserByByteArr (63)
/* Operation wrapper: */
struct __TMSServ2__loginUserByByteArr
{
public:
	_TMSServ__loginUserByByteArr *TMSServ__loginUserByByteArr;	/* optional element of type TMSServ:loginUserByByteArr */
public:
	int soap_type() const { return 63; } /* = unique type id SOAP_TYPE___TMSServ2__loginUserByByteArr */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__logoutUser
#define SOAP_TYPE___TMSServ2__logoutUser (67)
/* Operation wrapper: */
struct __TMSServ2__logoutUser
{
public:
	_TMSServ__logoutUser *TMSServ__logoutUser;	/* optional element of type TMSServ:logoutUser */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE___TMSServ2__logoutUser */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__QueryObjects
#define SOAP_TYPE___TMSServ2__QueryObjects (71)
/* Operation wrapper: */
struct __TMSServ2__QueryObjects
{
public:
	_TMSServ__QueryObjects *TMSServ__QueryObjects;	/* optional element of type TMSServ:QueryObjects */
public:
	int soap_type() const { return 71; } /* = unique type id SOAP_TYPE___TMSServ2__QueryObjects */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__DownloadObjects
#define SOAP_TYPE___TMSServ2__DownloadObjects (75)
/* Operation wrapper: */
struct __TMSServ2__DownloadObjects
{
public:
	_TMSServ__DownloadObjects *TMSServ__DownloadObjects;	/* optional element of type TMSServ:DownloadObjects */
public:
	int soap_type() const { return 75; } /* = unique type id SOAP_TYPE___TMSServ2__DownloadObjects */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__GetObjectsVersion
#define SOAP_TYPE___TMSServ2__GetObjectsVersion (79)
/* Operation wrapper: */
struct __TMSServ2__GetObjectsVersion
{
public:
	_TMSServ__GetObjectsVersion *TMSServ__GetObjectsVersion;	/* optional element of type TMSServ:GetObjectsVersion */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE___TMSServ2__GetObjectsVersion */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__GetTowerPartsLabelAndVersionSerial
#define SOAP_TYPE___TMSServ2__GetTowerPartsLabelAndVersionSerial (83)
/* Operation wrapper: */
struct __TMSServ2__GetTowerPartsLabelAndVersionSerial
{
public:
	_TMSServ__GetTowerPartsLabelAndVersionSerial *TMSServ__GetTowerPartsLabelAndVersionSerial;	/* optional element of type TMSServ:GetTowerPartsLabelAndVersionSerial */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE___TMSServ2__GetTowerPartsLabelAndVersionSerial */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__MatchTowerParts
#define SOAP_TYPE___TMSServ2__MatchTowerParts (87)
/* Operation wrapper: */
struct __TMSServ2__MatchTowerParts
{
public:
	_TMSServ__MatchTowerParts *TMSServ__MatchTowerParts;	/* optional element of type TMSServ:MatchTowerParts */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE___TMSServ2__MatchTowerParts */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__SaveOrUpdateObjects
#define SOAP_TYPE___TMSServ2__SaveOrUpdateObjects (91)
/* Operation wrapper: */
struct __TMSServ2__SaveOrUpdateObjects
{
public:
	_TMSServ__SaveOrUpdateObjects *TMSServ__SaveOrUpdateObjects;	/* optional element of type TMSServ:SaveOrUpdateObjects */
public:
	int soap_type() const { return 91; } /* = unique type id SOAP_TYPE___TMSServ2__SaveOrUpdateObjects */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__DeleteObject
#define SOAP_TYPE___TMSServ2__DeleteObject (95)
/* Operation wrapper: */
struct __TMSServ2__DeleteObject
{
public:
	_TMSServ__DeleteObject *TMSServ__DeleteObject;	/* optional element of type TMSServ:DeleteObject */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE___TMSServ2__DeleteObject */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__DownloadFileById
#define SOAP_TYPE___TMSServ2__DownloadFileById (99)
/* Operation wrapper: */
struct __TMSServ2__DownloadFileById
{
public:
	_TMSServ__DownloadFileById *TMSServ__DownloadFileById;	/* optional element of type TMSServ:DownloadFileById */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE___TMSServ2__DownloadFileById */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__UploadFileObject
#define SOAP_TYPE___TMSServ2__UploadFileObject (103)
/* Operation wrapper: */
struct __TMSServ2__UploadFileObject
{
public:
	_TMSServ__UploadFileObject *TMSServ__UploadFileObject;	/* optional element of type TMSServ:UploadFileObject */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE___TMSServ2__UploadFileObject */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__FinalizeFileObjectData
#define SOAP_TYPE___TMSServ2__FinalizeFileObjectData (107)
/* Operation wrapper: */
struct __TMSServ2__FinalizeFileObjectData
{
public:
	_TMSServ__FinalizeFileObjectData *TMSServ__FinalizeFileObjectData;	/* optional element of type TMSServ:FinalizeFileObjectData */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE___TMSServ2__FinalizeFileObjectData */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__OpenFileObjectDataProvider
#define SOAP_TYPE___TMSServ2__OpenFileObjectDataProvider (111)
/* Operation wrapper: */
struct __TMSServ2__OpenFileObjectDataProvider
{
public:
	_TMSServ__OpenFileObjectDataProvider *TMSServ__OpenFileObjectDataProvider;	/* optional element of type TMSServ:OpenFileObjectDataProvider */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE___TMSServ2__OpenFileObjectDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__OpenTapModelDataProvider
#define SOAP_TYPE___TMSServ2__OpenTapModelDataProvider (115)
/* Operation wrapper: */
struct __TMSServ2__OpenTapModelDataProvider
{
public:
	_TMSServ__OpenTapModelDataProvider *TMSServ__OpenTapModelDataProvider;	/* optional element of type TMSServ:OpenTapModelDataProvider */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE___TMSServ2__OpenTapModelDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__OpenServerObjectDataProvider
#define SOAP_TYPE___TMSServ2__OpenServerObjectDataProvider (119)
/* Operation wrapper: */
struct __TMSServ2__OpenServerObjectDataProvider
{
public:
	_TMSServ__OpenServerObjectDataProvider *TMSServ__OpenServerObjectDataProvider;	/* optional element of type TMSServ:OpenServerObjectDataProvider */
public:
	int soap_type() const { return 119; } /* = unique type id SOAP_TYPE___TMSServ2__OpenServerObjectDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__DownloadFileObject
#define SOAP_TYPE___TMSServ2__DownloadFileObject (123)
/* Operation wrapper: */
struct __TMSServ2__DownloadFileObject
{
public:
	_TMSServ__DownloadFileObject *TMSServ__DownloadFileObject;	/* optional element of type TMSServ:DownloadFileObject */
public:
	int soap_type() const { return 123; } /* = unique type id SOAP_TYPE___TMSServ2__DownloadFileObject */
};
#endif

#ifndef SOAP_TYPE___TMSServ2__CloseFileObjectDataProvider
#define SOAP_TYPE___TMSServ2__CloseFileObjectDataProvider (127)
/* Operation wrapper: */
struct __TMSServ2__CloseFileObjectDataProvider
{
public:
	_TMSServ__CloseFileObjectDataProvider *TMSServ__CloseFileObjectDataProvider;	/* optional element of type TMSServ:CloseFileObjectDataProvider */
public:
	int soap_type() const { return 127; } /* = unique type id SOAP_TYPE___TMSServ2__CloseFileObjectDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__loginUser
#define SOAP_TYPE___TMSServ3__loginUser (129)
/* Operation wrapper: */
struct __TMSServ3__loginUser
{
public:
	_TMSServ__loginUser *TMSServ__loginUser;	/* optional element of type TMSServ:loginUser */
public:
	int soap_type() const { return 129; } /* = unique type id SOAP_TYPE___TMSServ3__loginUser */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__loginUserByByteArr
#define SOAP_TYPE___TMSServ3__loginUserByByteArr (131)
/* Operation wrapper: */
struct __TMSServ3__loginUserByByteArr
{
public:
	_TMSServ__loginUserByByteArr *TMSServ__loginUserByByteArr;	/* optional element of type TMSServ:loginUserByByteArr */
public:
	int soap_type() const { return 131; } /* = unique type id SOAP_TYPE___TMSServ3__loginUserByByteArr */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__logoutUser
#define SOAP_TYPE___TMSServ3__logoutUser (133)
/* Operation wrapper: */
struct __TMSServ3__logoutUser
{
public:
	_TMSServ__logoutUser *TMSServ__logoutUser;	/* optional element of type TMSServ:logoutUser */
public:
	int soap_type() const { return 133; } /* = unique type id SOAP_TYPE___TMSServ3__logoutUser */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__QueryObjects
#define SOAP_TYPE___TMSServ3__QueryObjects (135)
/* Operation wrapper: */
struct __TMSServ3__QueryObjects
{
public:
	_TMSServ__QueryObjects *TMSServ__QueryObjects;	/* optional element of type TMSServ:QueryObjects */
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE___TMSServ3__QueryObjects */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__DownloadObjects
#define SOAP_TYPE___TMSServ3__DownloadObjects (137)
/* Operation wrapper: */
struct __TMSServ3__DownloadObjects
{
public:
	_TMSServ__DownloadObjects *TMSServ__DownloadObjects;	/* optional element of type TMSServ:DownloadObjects */
public:
	int soap_type() const { return 137; } /* = unique type id SOAP_TYPE___TMSServ3__DownloadObjects */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__GetObjectsVersion
#define SOAP_TYPE___TMSServ3__GetObjectsVersion (139)
/* Operation wrapper: */
struct __TMSServ3__GetObjectsVersion
{
public:
	_TMSServ__GetObjectsVersion *TMSServ__GetObjectsVersion;	/* optional element of type TMSServ:GetObjectsVersion */
public:
	int soap_type() const { return 139; } /* = unique type id SOAP_TYPE___TMSServ3__GetObjectsVersion */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__GetTowerPartsLabelAndVersionSerial
#define SOAP_TYPE___TMSServ3__GetTowerPartsLabelAndVersionSerial (141)
/* Operation wrapper: */
struct __TMSServ3__GetTowerPartsLabelAndVersionSerial
{
public:
	_TMSServ__GetTowerPartsLabelAndVersionSerial *TMSServ__GetTowerPartsLabelAndVersionSerial;	/* optional element of type TMSServ:GetTowerPartsLabelAndVersionSerial */
public:
	int soap_type() const { return 141; } /* = unique type id SOAP_TYPE___TMSServ3__GetTowerPartsLabelAndVersionSerial */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__MatchTowerParts
#define SOAP_TYPE___TMSServ3__MatchTowerParts (143)
/* Operation wrapper: */
struct __TMSServ3__MatchTowerParts
{
public:
	_TMSServ__MatchTowerParts *TMSServ__MatchTowerParts;	/* optional element of type TMSServ:MatchTowerParts */
public:
	int soap_type() const { return 143; } /* = unique type id SOAP_TYPE___TMSServ3__MatchTowerParts */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__SaveOrUpdateObjects
#define SOAP_TYPE___TMSServ3__SaveOrUpdateObjects (145)
/* Operation wrapper: */
struct __TMSServ3__SaveOrUpdateObjects
{
public:
	_TMSServ__SaveOrUpdateObjects *TMSServ__SaveOrUpdateObjects;	/* optional element of type TMSServ:SaveOrUpdateObjects */
public:
	int soap_type() const { return 145; } /* = unique type id SOAP_TYPE___TMSServ3__SaveOrUpdateObjects */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__DeleteObject
#define SOAP_TYPE___TMSServ3__DeleteObject (147)
/* Operation wrapper: */
struct __TMSServ3__DeleteObject
{
public:
	_TMSServ__DeleteObject *TMSServ__DeleteObject;	/* optional element of type TMSServ:DeleteObject */
public:
	int soap_type() const { return 147; } /* = unique type id SOAP_TYPE___TMSServ3__DeleteObject */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__DownloadFileById
#define SOAP_TYPE___TMSServ3__DownloadFileById (149)
/* Operation wrapper: */
struct __TMSServ3__DownloadFileById
{
public:
	_TMSServ__DownloadFileById *TMSServ__DownloadFileById;	/* optional element of type TMSServ:DownloadFileById */
public:
	int soap_type() const { return 149; } /* = unique type id SOAP_TYPE___TMSServ3__DownloadFileById */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__UploadFileObject
#define SOAP_TYPE___TMSServ3__UploadFileObject (151)
/* Operation wrapper: */
struct __TMSServ3__UploadFileObject
{
public:
	_TMSServ__UploadFileObject *TMSServ__UploadFileObject;	/* optional element of type TMSServ:UploadFileObject */
public:
	int soap_type() const { return 151; } /* = unique type id SOAP_TYPE___TMSServ3__UploadFileObject */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__FinalizeFileObjectData
#define SOAP_TYPE___TMSServ3__FinalizeFileObjectData (153)
/* Operation wrapper: */
struct __TMSServ3__FinalizeFileObjectData
{
public:
	_TMSServ__FinalizeFileObjectData *TMSServ__FinalizeFileObjectData;	/* optional element of type TMSServ:FinalizeFileObjectData */
public:
	int soap_type() const { return 153; } /* = unique type id SOAP_TYPE___TMSServ3__FinalizeFileObjectData */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__OpenFileObjectDataProvider
#define SOAP_TYPE___TMSServ3__OpenFileObjectDataProvider (155)
/* Operation wrapper: */
struct __TMSServ3__OpenFileObjectDataProvider
{
public:
	_TMSServ__OpenFileObjectDataProvider *TMSServ__OpenFileObjectDataProvider;	/* optional element of type TMSServ:OpenFileObjectDataProvider */
public:
	int soap_type() const { return 155; } /* = unique type id SOAP_TYPE___TMSServ3__OpenFileObjectDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__OpenTapModelDataProvider
#define SOAP_TYPE___TMSServ3__OpenTapModelDataProvider (157)
/* Operation wrapper: */
struct __TMSServ3__OpenTapModelDataProvider
{
public:
	_TMSServ__OpenTapModelDataProvider *TMSServ__OpenTapModelDataProvider;	/* optional element of type TMSServ:OpenTapModelDataProvider */
public:
	int soap_type() const { return 157; } /* = unique type id SOAP_TYPE___TMSServ3__OpenTapModelDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__OpenServerObjectDataProvider
#define SOAP_TYPE___TMSServ3__OpenServerObjectDataProvider (159)
/* Operation wrapper: */
struct __TMSServ3__OpenServerObjectDataProvider
{
public:
	_TMSServ__OpenServerObjectDataProvider *TMSServ__OpenServerObjectDataProvider;	/* optional element of type TMSServ:OpenServerObjectDataProvider */
public:
	int soap_type() const { return 159; } /* = unique type id SOAP_TYPE___TMSServ3__OpenServerObjectDataProvider */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__DownloadFileObject
#define SOAP_TYPE___TMSServ3__DownloadFileObject (161)
/* Operation wrapper: */
struct __TMSServ3__DownloadFileObject
{
public:
	_TMSServ__DownloadFileObject *TMSServ__DownloadFileObject;	/* optional element of type TMSServ:DownloadFileObject */
public:
	int soap_type() const { return 161; } /* = unique type id SOAP_TYPE___TMSServ3__DownloadFileObject */
};
#endif

#ifndef SOAP_TYPE___TMSServ3__CloseFileObjectDataProvider
#define SOAP_TYPE___TMSServ3__CloseFileObjectDataProvider (163)
/* Operation wrapper: */
struct __TMSServ3__CloseFileObjectDataProvider
{
public:
	_TMSServ__CloseFileObjectDataProvider *TMSServ__CloseFileObjectDataProvider;	/* optional element of type TMSServ:CloseFileObjectDataProvider */
public:
	int soap_type() const { return 163; } /* = unique type id SOAP_TYPE___TMSServ3__CloseFileObjectDataProvider */
};
#endif

#ifndef SOAP_TYPE_VersionServ__ArrayOfProductVersion
#define SOAP_TYPE_VersionServ__ArrayOfProductVersion (166)
/* VersionServ:ArrayOfProductVersion */
class SOAP_CMAC VersionServ__ArrayOfProductVersion
{
public:
	int __sizeProductVersion;	/* sequence of elements <ProductVersion> */
	class VersionServ__ProductVersion **ProductVersion;	/* optional element of type VersionServ:ProductVersion */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique type id SOAP_TYPE_VersionServ__ArrayOfProductVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__ArrayOfProductVersion() { VersionServ__ArrayOfProductVersion::soap_default(NULL); }
	virtual ~VersionServ__ArrayOfProductVersion() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__ProductVersion
#define SOAP_TYPE_VersionServ__ProductVersion (167)
/* VersionServ:ProductVersion */
class SOAP_CMAC VersionServ__ProductVersion
{
public:
	int id;	/* required element of type xsd:int */
	unsigned int productId;	/* required element of type xsd:unsignedInt */
	unsigned int version;	/* required element of type xsd:unsignedInt */
	time_t releaseDate;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique type id SOAP_TYPE_VersionServ__ProductVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__ProductVersion() { VersionServ__ProductVersion::soap_default(NULL); }
	virtual ~VersionServ__ProductVersion() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__ArrayOfInt
#define SOAP_TYPE_VersionServ__ArrayOfInt (168)
/* VersionServ:ArrayOfInt */
class SOAP_CMAC VersionServ__ArrayOfInt
{
public:
	int __sizeint_;	/* sequence of elements <int> */
	int *int_;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique type id SOAP_TYPE_VersionServ__ArrayOfInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__ArrayOfInt() { VersionServ__ArrayOfInt::soap_default(NULL); }
	virtual ~VersionServ__ArrayOfInt() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__ArrayOfVersionRevision
#define SOAP_TYPE_VersionServ__ArrayOfVersionRevision (169)
/* VersionServ:ArrayOfVersionRevision */
class SOAP_CMAC VersionServ__ArrayOfVersionRevision
{
public:
	int __sizeVersionRevision;	/* sequence of elements <VersionRevision> */
	class VersionServ__VersionRevision **VersionRevision;	/* optional element of type VersionServ:VersionRevision */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique type id SOAP_TYPE_VersionServ__ArrayOfVersionRevision */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__ArrayOfVersionRevision() { VersionServ__ArrayOfVersionRevision::soap_default(NULL); }
	virtual ~VersionServ__ArrayOfVersionRevision() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__VersionRevision
#define SOAP_TYPE_VersionServ__VersionRevision (170)
/* VersionServ:VersionRevision */
class SOAP_CMAC VersionServ__VersionRevision
{
public:
	unsigned int Id;	/* required element of type xsd:unsignedInt */
	unsigned int productId;	/* required element of type xsd:unsignedInt */
	char revisionType;	/* required element of type xsd:byte */
	unsigned char important;	/* required element of type xsd:unsignedByte */
	bool readed;	/* required element of type xsd:boolean */
	char *title;	/* optional element of type xsd:string */
	char *contents;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique type id SOAP_TYPE_VersionServ__VersionRevision */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__VersionRevision() { VersionServ__VersionRevision::soap_default(NULL); }
	virtual ~VersionServ__VersionRevision() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__ObjectV
#define SOAP_TYPE_VersionServ__ObjectV (172)
/* VersionServ:ObjectV */
class SOAP_CMAC VersionServ__ObjectV
{
public:
	int id;	/* required element of type xsd:int */
	char *tag;	/* optional element of type xsd:anyType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique type id SOAP_TYPE_VersionServ__ObjectV */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__ObjectV() { VersionServ__ObjectV::soap_default(NULL); }
	virtual ~VersionServ__ObjectV() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__ArrayOfDownLoadItem
#define SOAP_TYPE_VersionServ__ArrayOfDownLoadItem (173)
/* VersionServ:ArrayOfDownLoadItem */
class SOAP_CMAC VersionServ__ArrayOfDownLoadItem
{
public:
	int __sizeDownLoadItem;	/* sequence of elements <DownLoadItem> */
	class VersionServ__DownLoadItem **DownLoadItem;	/* optional element of type VersionServ:DownLoadItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique type id SOAP_TYPE_VersionServ__ArrayOfDownLoadItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__ArrayOfDownLoadItem() { VersionServ__ArrayOfDownLoadItem::soap_default(NULL); }
	virtual ~VersionServ__ArrayOfDownLoadItem() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__Login
#define SOAP_TYPE__VersionServ__Login (176)
/* VersionServ:Login */
class SOAP_CMAC _VersionServ__Login
{
public:
	xsd__base64Binary *computerMac;	/* optional element of type xsd:base64Binary */
	xsd__base64Binary *computerIp;	/* optional element of type xsd:base64Binary */
	char *computerName;	/* optional element of type xsd:string */
	unsigned int dogSerial;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique type id SOAP_TYPE__VersionServ__Login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__Login() { _VersionServ__Login::soap_default(NULL); }
	virtual ~_VersionServ__Login() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__LoginResponse
#define SOAP_TYPE__VersionServ__LoginResponse (177)
/* VersionServ:LoginResponse */
class SOAP_CMAC _VersionServ__LoginResponse
{
public:
	unsigned int LoginResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique type id SOAP_TYPE__VersionServ__LoginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__LoginResponse() { _VersionServ__LoginResponse::soap_default(NULL); }
	virtual ~_VersionServ__LoginResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__LoginByByteArr
#define SOAP_TYPE__VersionServ__LoginByByteArr (178)
/* VersionServ:LoginByByteArr */
class SOAP_CMAC _VersionServ__LoginByByteArr
{
public:
	xsd__base64Binary *userInfo;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique type id SOAP_TYPE__VersionServ__LoginByByteArr */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__LoginByByteArr() { _VersionServ__LoginByByteArr::soap_default(NULL); }
	virtual ~_VersionServ__LoginByByteArr() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__LoginByByteArrResponse
#define SOAP_TYPE__VersionServ__LoginByByteArrResponse (179)
/* VersionServ:LoginByByteArrResponse */
class SOAP_CMAC _VersionServ__LoginByByteArrResponse
{
public:
	unsigned int LoginByByteArrResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique type id SOAP_TYPE__VersionServ__LoginByByteArrResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__LoginByByteArrResponse() { _VersionServ__LoginByByteArrResponse::soap_default(NULL); }
	virtual ~_VersionServ__LoginByByteArrResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetUpdateVerByCurVer
#define SOAP_TYPE__VersionServ__GetUpdateVerByCurVer (180)
/* VersionServ:GetUpdateVerByCurVer */
class SOAP_CMAC _VersionServ__GetUpdateVerByCurVer
{
public:
	unsigned int userId;	/* required element of type xsd:unsignedInt */
	unsigned int product_USCOREid;	/* required element of type xsd:unsignedInt */
	unsigned int uCurVersion;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique type id SOAP_TYPE__VersionServ__GetUpdateVerByCurVer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetUpdateVerByCurVer() { _VersionServ__GetUpdateVerByCurVer::soap_default(NULL); }
	virtual ~_VersionServ__GetUpdateVerByCurVer() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetUpdateVerByCurVerResponse
#define SOAP_TYPE__VersionServ__GetUpdateVerByCurVerResponse (181)
/* VersionServ:GetUpdateVerByCurVerResponse */
class SOAP_CMAC _VersionServ__GetUpdateVerByCurVerResponse
{
public:
	VersionServ__ArrayOfProductVersion *GetUpdateVerByCurVerResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type VersionServ:ArrayOfProductVersion */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique type id SOAP_TYPE__VersionServ__GetUpdateVerByCurVerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetUpdateVerByCurVerResponse() { _VersionServ__GetUpdateVerByCurVerResponse::soap_default(NULL); }
	virtual ~_VersionServ__GetUpdateVerByCurVerResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__SetRevisionReadFlag
#define SOAP_TYPE__VersionServ__SetRevisionReadFlag (182)
/* VersionServ:SetRevisionReadFlag */
class SOAP_CMAC _VersionServ__SetRevisionReadFlag
{
public:
	int userId;	/* required element of type xsd:int */
	VersionServ__ArrayOfInt *revisionIdArr;	/* optional element of type VersionServ:ArrayOfInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique type id SOAP_TYPE__VersionServ__SetRevisionReadFlag */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__SetRevisionReadFlag() { _VersionServ__SetRevisionReadFlag::soap_default(NULL); }
	virtual ~_VersionServ__SetRevisionReadFlag() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__SetRevisionReadFlagResponse
#define SOAP_TYPE__VersionServ__SetRevisionReadFlagResponse (183)
/* VersionServ:SetRevisionReadFlagResponse */
class SOAP_CMAC _VersionServ__SetRevisionReadFlagResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique type id SOAP_TYPE__VersionServ__SetRevisionReadFlagResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__SetRevisionReadFlagResponse() { _VersionServ__SetRevisionReadFlagResponse::soap_default(NULL); }
	virtual ~_VersionServ__SetRevisionReadFlagResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__CompareVersion
#define SOAP_TYPE__VersionServ__CompareVersion (184)
/* VersionServ:CompareVersion */
class SOAP_CMAC _VersionServ__CompareVersion
{
public:
	int userId;	/* required element of type xsd:int */
	unsigned int product_USCOREid;	/* required element of type xsd:unsignedInt */
	unsigned int uCurVersion;	/* required element of type xsd:unsignedInt */
	unsigned int uUpdateVersion;	/* required element of type xsd:unsignedInt */
	bool bLoadOnHasNew;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique type id SOAP_TYPE__VersionServ__CompareVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__CompareVersion() { _VersionServ__CompareVersion::soap_default(NULL); }
	virtual ~_VersionServ__CompareVersion() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__CompareVersionResponse
#define SOAP_TYPE__VersionServ__CompareVersionResponse (185)
/* VersionServ:CompareVersionResponse */
class SOAP_CMAC _VersionServ__CompareVersionResponse
{
public:
	VersionServ__ArrayOfVersionRevision *CompareVersionResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type VersionServ:ArrayOfVersionRevision */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique type id SOAP_TYPE__VersionServ__CompareVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__CompareVersionResponse() { _VersionServ__CompareVersionResponse::soap_default(NULL); }
	virtual ~_VersionServ__CompareVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetVersionReleaseNotes
#define SOAP_TYPE__VersionServ__GetVersionReleaseNotes (186)
/* VersionServ:GetVersionReleaseNotes */
class SOAP_CMAC _VersionServ__GetVersionReleaseNotes
{
public:
	unsigned int product_USCOREid;	/* required element of type xsd:unsignedInt */
	unsigned int uCurVersion;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 186; } /* = unique type id SOAP_TYPE__VersionServ__GetVersionReleaseNotes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetVersionReleaseNotes() { _VersionServ__GetVersionReleaseNotes::soap_default(NULL); }
	virtual ~_VersionServ__GetVersionReleaseNotes() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetVersionReleaseNotesResponse
#define SOAP_TYPE__VersionServ__GetVersionReleaseNotesResponse (187)
/* VersionServ:GetVersionReleaseNotesResponse */
class SOAP_CMAC _VersionServ__GetVersionReleaseNotesResponse
{
public:
	VersionServ__ArrayOfVersionRevision *GetVersionReleaseNotesResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type VersionServ:ArrayOfVersionRevision */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique type id SOAP_TYPE__VersionServ__GetVersionReleaseNotesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetVersionReleaseNotesResponse() { _VersionServ__GetVersionReleaseNotesResponse::soap_default(NULL); }
	virtual ~_VersionServ__GetVersionReleaseNotesResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetDogAccessHistory
#define SOAP_TYPE__VersionServ__GetDogAccessHistory (188)
/* VersionServ:GetDogAccessHistory */
class SOAP_CMAC _VersionServ__GetDogAccessHistory
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 188; } /* = unique type id SOAP_TYPE__VersionServ__GetDogAccessHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetDogAccessHistory() { _VersionServ__GetDogAccessHistory::soap_default(NULL); }
	virtual ~_VersionServ__GetDogAccessHistory() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetDogAccessHistoryResponse
#define SOAP_TYPE__VersionServ__GetDogAccessHistoryResponse (189)
/* VersionServ:GetDogAccessHistoryResponse */
class SOAP_CMAC _VersionServ__GetDogAccessHistoryResponse
{
public:
	class VersionServ__DogAccessHistory *GetDogAccessHistoryResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type VersionServ:DogAccessHistory */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 189; } /* = unique type id SOAP_TYPE__VersionServ__GetDogAccessHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetDogAccessHistoryResponse() { _VersionServ__GetDogAccessHistoryResponse::soap_default(NULL); }
	virtual ~_VersionServ__GetDogAccessHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__QueryDownLoadItemArrByProductId
#define SOAP_TYPE__VersionServ__QueryDownLoadItemArrByProductId (190)
/* VersionServ:QueryDownLoadItemArrByProductId */
class SOAP_CMAC _VersionServ__QueryDownLoadItemArrByProductId
{
public:
	char *dogNo;	/* optional element of type xsd:string */
	int productId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique type id SOAP_TYPE__VersionServ__QueryDownLoadItemArrByProductId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__QueryDownLoadItemArrByProductId() { _VersionServ__QueryDownLoadItemArrByProductId::soap_default(NULL); }
	virtual ~_VersionServ__QueryDownLoadItemArrByProductId() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__QueryDownLoadItemArrByProductIdResponse
#define SOAP_TYPE__VersionServ__QueryDownLoadItemArrByProductIdResponse (191)
/* VersionServ:QueryDownLoadItemArrByProductIdResponse */
class SOAP_CMAC _VersionServ__QueryDownLoadItemArrByProductIdResponse
{
public:
	VersionServ__ArrayOfDownLoadItem *QueryDownLoadItemArrByProductIdResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type VersionServ:ArrayOfDownLoadItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique type id SOAP_TYPE__VersionServ__QueryDownLoadItemArrByProductIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__QueryDownLoadItemArrByProductIdResponse() { _VersionServ__QueryDownLoadItemArrByProductIdResponse::soap_default(NULL); }
	virtual ~_VersionServ__QueryDownLoadItemArrByProductIdResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetFileHeader
#define SOAP_TYPE__VersionServ__GetFileHeader (192)
/* VersionServ:GetFileHeader */
class SOAP_CMAC _VersionServ__GetFileHeader
{
public:
	int downLoadItemId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 192; } /* = unique type id SOAP_TYPE__VersionServ__GetFileHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetFileHeader() { _VersionServ__GetFileHeader::soap_default(NULL); }
	virtual ~_VersionServ__GetFileHeader() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__GetFileHeaderResponse
#define SOAP_TYPE__VersionServ__GetFileHeaderResponse (193)
/* VersionServ:GetFileHeaderResponse */
class SOAP_CMAC _VersionServ__GetFileHeaderResponse
{
public:
	class VersionServ__FileHeader *GetFileHeaderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type VersionServ:FileHeader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique type id SOAP_TYPE__VersionServ__GetFileHeaderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__GetFileHeaderResponse() { _VersionServ__GetFileHeaderResponse::soap_default(NULL); }
	virtual ~_VersionServ__GetFileHeaderResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__QueryObjects
#define SOAP_TYPE__VersionServ__QueryObjects (194)
/* VersionServ:QueryObjects */
class SOAP_CMAC _VersionServ__QueryObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	char *xmlScope;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique type id SOAP_TYPE__VersionServ__QueryObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__QueryObjects() { _VersionServ__QueryObjects::soap_default(NULL); }
	virtual ~_VersionServ__QueryObjects() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__QueryObjectsResponse
#define SOAP_TYPE__VersionServ__QueryObjectsResponse (195)
/* VersionServ:QueryObjectsResponse */
class SOAP_CMAC _VersionServ__QueryObjectsResponse
{
public:
	xsd__base64Binary *QueryObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 195; } /* = unique type id SOAP_TYPE__VersionServ__QueryObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__QueryObjectsResponse() { _VersionServ__QueryObjectsResponse::soap_default(NULL); }
	virtual ~_VersionServ__QueryObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__DownloadObjects
#define SOAP_TYPE__VersionServ__DownloadObjects (196)
/* VersionServ:DownloadObjects */
class SOAP_CMAC _VersionServ__DownloadObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	VersionServ__ArrayOfInt *idarr;	/* optional element of type VersionServ:ArrayOfInt */
	unsigned int serialize;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 196; } /* = unique type id SOAP_TYPE__VersionServ__DownloadObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__DownloadObjects() { _VersionServ__DownloadObjects::soap_default(NULL); }
	virtual ~_VersionServ__DownloadObjects() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__DownloadObjectsResponse
#define SOAP_TYPE__VersionServ__DownloadObjectsResponse (197)
/* VersionServ:DownloadObjectsResponse */
class SOAP_CMAC _VersionServ__DownloadObjectsResponse
{
public:
	xsd__base64Binary *DownloadObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique type id SOAP_TYPE__VersionServ__DownloadObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__DownloadObjectsResponse() { _VersionServ__DownloadObjectsResponse::soap_default(NULL); }
	virtual ~_VersionServ__DownloadObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__SaveOrUpdateObjects
#define SOAP_TYPE__VersionServ__SaveOrUpdateObjects (198)
/* VersionServ:SaveOrUpdateObjects */
class SOAP_CMAC _VersionServ__SaveOrUpdateObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	char *xmlformat;	/* optional element of type xsd:string */
	xsd__base64Binary *byteArr;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique type id SOAP_TYPE__VersionServ__SaveOrUpdateObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__SaveOrUpdateObjects() { _VersionServ__SaveOrUpdateObjects::soap_default(NULL); }
	virtual ~_VersionServ__SaveOrUpdateObjects() { }
};
#endif

#ifndef SOAP_TYPE__VersionServ__SaveOrUpdateObjectsResponse
#define SOAP_TYPE__VersionServ__SaveOrUpdateObjectsResponse (199)
/* VersionServ:SaveOrUpdateObjectsResponse */
class SOAP_CMAC _VersionServ__SaveOrUpdateObjectsResponse
{
public:
	char *SaveOrUpdateObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 199; } /* = unique type id SOAP_TYPE__VersionServ__SaveOrUpdateObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _VersionServ__SaveOrUpdateObjectsResponse() { _VersionServ__SaveOrUpdateObjectsResponse::soap_default(NULL); }
	virtual ~_VersionServ__SaveOrUpdateObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__DogAccessHistory
#define SOAP_TYPE_VersionServ__DogAccessHistory (171)
/* VersionServ:DogAccessHistory */
class SOAP_CMAC VersionServ__DogAccessHistory : public VersionServ__ObjectV
{
public:
	char *dogserial;	/* optional element of type xsd:string */
	int endUserId;	/* required element of type xsd:int */
	int productId;	/* required element of type xsd:int */
	int cycleSerial;	/* required element of type xsd:int */
	int accessType;	/* required element of type xsd:int */
	int accessOccurDate;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 171; } /* = unique type id SOAP_TYPE_VersionServ__DogAccessHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__DogAccessHistory() { VersionServ__DogAccessHistory::soap_default(NULL); }
	virtual ~VersionServ__DogAccessHistory() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__DownLoadItem
#define SOAP_TYPE_VersionServ__DownLoadItem (174)
/* VersionServ:DownLoadItem */
class SOAP_CMAC VersionServ__DownLoadItem : public VersionServ__ObjectV
{
public:
	char *title;	/* optional element of type xsd:string */
	time_t updateDate;	/* required element of type xsd:dateTime */
	char *notes;	/* optional element of type xsd:string */
	int serialno;	/* required element of type xsd:int */
	char *occurDateValue;	/* optional element of type xsd:string */
	char *fileName;	/* optional element of type xsd:string */
	int productId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 174; } /* = unique type id SOAP_TYPE_VersionServ__DownLoadItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__DownLoadItem() { VersionServ__DownLoadItem::soap_default(NULL); }
	virtual ~VersionServ__DownLoadItem() { }
};
#endif

#ifndef SOAP_TYPE_VersionServ__FileHeader
#define SOAP_TYPE_VersionServ__FileHeader (175)
/* VersionServ:FileHeader */
class SOAP_CMAC VersionServ__FileHeader : public VersionServ__ObjectV
{
public:
	char *filePath;	/* optional element of type xsd:string */
	int fileType;	/* required element of type xsd:int */
	char *fileName;	/* optional element of type xsd:string */
	char *fileNameServer;	/* optional element of type xsd:string */
	int hostId;	/* required element of type xsd:int */
	int ownerId;	/* required element of type xsd:int */
	xsd__base64Binary *matter;	/* optional element of type xsd:base64Binary */
	char *description;	/* optional element of type xsd:string */
	time_t occurDateValue;	/* required element of type xsd:dateTime */
	int serialNo;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 175; } /* = unique type id SOAP_TYPE_VersionServ__FileHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         VersionServ__FileHeader() { VersionServ__FileHeader::soap_default(NULL); }
	virtual ~VersionServ__FileHeader() { }
};
#endif

#ifndef SOAP_TYPE___VersionServ2__Login
#define SOAP_TYPE___VersionServ2__Login (216)
/* Operation wrapper: */
struct __VersionServ2__Login
{
public:
	_VersionServ__Login *VersionServ__Login;	/* optional element of type VersionServ:Login */
public:
	int soap_type() const { return 216; } /* = unique type id SOAP_TYPE___VersionServ2__Login */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__LoginByByteArr
#define SOAP_TYPE___VersionServ2__LoginByByteArr (220)
/* Operation wrapper: */
struct __VersionServ2__LoginByByteArr
{
public:
	_VersionServ__LoginByByteArr *VersionServ__LoginByByteArr;	/* optional element of type VersionServ:LoginByByteArr */
public:
	int soap_type() const { return 220; } /* = unique type id SOAP_TYPE___VersionServ2__LoginByByteArr */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__GetUpdateVerByCurVer
#define SOAP_TYPE___VersionServ2__GetUpdateVerByCurVer (224)
/* Operation wrapper: */
struct __VersionServ2__GetUpdateVerByCurVer
{
public:
	_VersionServ__GetUpdateVerByCurVer *VersionServ__GetUpdateVerByCurVer;	/* optional element of type VersionServ:GetUpdateVerByCurVer */
public:
	int soap_type() const { return 224; } /* = unique type id SOAP_TYPE___VersionServ2__GetUpdateVerByCurVer */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__SetRevisionReadFlag
#define SOAP_TYPE___VersionServ2__SetRevisionReadFlag (228)
/* Operation wrapper: */
struct __VersionServ2__SetRevisionReadFlag
{
public:
	_VersionServ__SetRevisionReadFlag *VersionServ__SetRevisionReadFlag;	/* optional element of type VersionServ:SetRevisionReadFlag */
public:
	int soap_type() const { return 228; } /* = unique type id SOAP_TYPE___VersionServ2__SetRevisionReadFlag */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__CompareVersion
#define SOAP_TYPE___VersionServ2__CompareVersion (232)
/* Operation wrapper: */
struct __VersionServ2__CompareVersion
{
public:
	_VersionServ__CompareVersion *VersionServ__CompareVersion;	/* optional element of type VersionServ:CompareVersion */
public:
	int soap_type() const { return 232; } /* = unique type id SOAP_TYPE___VersionServ2__CompareVersion */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__GetVersionReleaseNotes
#define SOAP_TYPE___VersionServ2__GetVersionReleaseNotes (236)
/* Operation wrapper: */
struct __VersionServ2__GetVersionReleaseNotes
{
public:
	_VersionServ__GetVersionReleaseNotes *VersionServ__GetVersionReleaseNotes;	/* optional element of type VersionServ:GetVersionReleaseNotes */
public:
	int soap_type() const { return 236; } /* = unique type id SOAP_TYPE___VersionServ2__GetVersionReleaseNotes */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__GetDogAccessHistory
#define SOAP_TYPE___VersionServ2__GetDogAccessHistory (240)
/* Operation wrapper: */
struct __VersionServ2__GetDogAccessHistory
{
public:
	_VersionServ__GetDogAccessHistory *VersionServ__GetDogAccessHistory;	/* optional element of type VersionServ:GetDogAccessHistory */
public:
	int soap_type() const { return 240; } /* = unique type id SOAP_TYPE___VersionServ2__GetDogAccessHistory */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__QueryDownLoadItemArrByProductId
#define SOAP_TYPE___VersionServ2__QueryDownLoadItemArrByProductId (244)
/* Operation wrapper: */
struct __VersionServ2__QueryDownLoadItemArrByProductId
{
public:
	_VersionServ__QueryDownLoadItemArrByProductId *VersionServ__QueryDownLoadItemArrByProductId;	/* optional element of type VersionServ:QueryDownLoadItemArrByProductId */
public:
	int soap_type() const { return 244; } /* = unique type id SOAP_TYPE___VersionServ2__QueryDownLoadItemArrByProductId */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__GetFileHeader
#define SOAP_TYPE___VersionServ2__GetFileHeader (248)
/* Operation wrapper: */
struct __VersionServ2__GetFileHeader
{
public:
	_VersionServ__GetFileHeader *VersionServ__GetFileHeader;	/* optional element of type VersionServ:GetFileHeader */
public:
	int soap_type() const { return 248; } /* = unique type id SOAP_TYPE___VersionServ2__GetFileHeader */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__QueryObjects
#define SOAP_TYPE___VersionServ2__QueryObjects (252)
/* Operation wrapper: */
struct __VersionServ2__QueryObjects
{
public:
	_VersionServ__QueryObjects *VersionServ__QueryObjects;	/* optional element of type VersionServ:QueryObjects */
public:
	int soap_type() const { return 252; } /* = unique type id SOAP_TYPE___VersionServ2__QueryObjects */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__DownloadObjects
#define SOAP_TYPE___VersionServ2__DownloadObjects (256)
/* Operation wrapper: */
struct __VersionServ2__DownloadObjects
{
public:
	_VersionServ__DownloadObjects *VersionServ__DownloadObjects;	/* optional element of type VersionServ:DownloadObjects */
public:
	int soap_type() const { return 256; } /* = unique type id SOAP_TYPE___VersionServ2__DownloadObjects */
};
#endif

#ifndef SOAP_TYPE___VersionServ2__SaveOrUpdateObjects
#define SOAP_TYPE___VersionServ2__SaveOrUpdateObjects (260)
/* Operation wrapper: */
struct __VersionServ2__SaveOrUpdateObjects
{
public:
	_VersionServ__SaveOrUpdateObjects *VersionServ__SaveOrUpdateObjects;	/* optional element of type VersionServ:SaveOrUpdateObjects */
public:
	int soap_type() const { return 260; } /* = unique type id SOAP_TYPE___VersionServ2__SaveOrUpdateObjects */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__Login
#define SOAP_TYPE___VersionServ3__Login (262)
/* Operation wrapper: */
struct __VersionServ3__Login
{
public:
	_VersionServ__Login *VersionServ__Login;	/* optional element of type VersionServ:Login */
public:
	int soap_type() const { return 262; } /* = unique type id SOAP_TYPE___VersionServ3__Login */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__LoginByByteArr
#define SOAP_TYPE___VersionServ3__LoginByByteArr (264)
/* Operation wrapper: */
struct __VersionServ3__LoginByByteArr
{
public:
	_VersionServ__LoginByByteArr *VersionServ__LoginByByteArr;	/* optional element of type VersionServ:LoginByByteArr */
public:
	int soap_type() const { return 264; } /* = unique type id SOAP_TYPE___VersionServ3__LoginByByteArr */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__GetUpdateVerByCurVer
#define SOAP_TYPE___VersionServ3__GetUpdateVerByCurVer (266)
/* Operation wrapper: */
struct __VersionServ3__GetUpdateVerByCurVer
{
public:
	_VersionServ__GetUpdateVerByCurVer *VersionServ__GetUpdateVerByCurVer;	/* optional element of type VersionServ:GetUpdateVerByCurVer */
public:
	int soap_type() const { return 266; } /* = unique type id SOAP_TYPE___VersionServ3__GetUpdateVerByCurVer */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__SetRevisionReadFlag
#define SOAP_TYPE___VersionServ3__SetRevisionReadFlag (268)
/* Operation wrapper: */
struct __VersionServ3__SetRevisionReadFlag
{
public:
	_VersionServ__SetRevisionReadFlag *VersionServ__SetRevisionReadFlag;	/* optional element of type VersionServ:SetRevisionReadFlag */
public:
	int soap_type() const { return 268; } /* = unique type id SOAP_TYPE___VersionServ3__SetRevisionReadFlag */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__CompareVersion
#define SOAP_TYPE___VersionServ3__CompareVersion (270)
/* Operation wrapper: */
struct __VersionServ3__CompareVersion
{
public:
	_VersionServ__CompareVersion *VersionServ__CompareVersion;	/* optional element of type VersionServ:CompareVersion */
public:
	int soap_type() const { return 270; } /* = unique type id SOAP_TYPE___VersionServ3__CompareVersion */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__GetVersionReleaseNotes
#define SOAP_TYPE___VersionServ3__GetVersionReleaseNotes (272)
/* Operation wrapper: */
struct __VersionServ3__GetVersionReleaseNotes
{
public:
	_VersionServ__GetVersionReleaseNotes *VersionServ__GetVersionReleaseNotes;	/* optional element of type VersionServ:GetVersionReleaseNotes */
public:
	int soap_type() const { return 272; } /* = unique type id SOAP_TYPE___VersionServ3__GetVersionReleaseNotes */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__GetDogAccessHistory
#define SOAP_TYPE___VersionServ3__GetDogAccessHistory (274)
/* Operation wrapper: */
struct __VersionServ3__GetDogAccessHistory
{
public:
	_VersionServ__GetDogAccessHistory *VersionServ__GetDogAccessHistory;	/* optional element of type VersionServ:GetDogAccessHistory */
public:
	int soap_type() const { return 274; } /* = unique type id SOAP_TYPE___VersionServ3__GetDogAccessHistory */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__QueryDownLoadItemArrByProductId
#define SOAP_TYPE___VersionServ3__QueryDownLoadItemArrByProductId (276)
/* Operation wrapper: */
struct __VersionServ3__QueryDownLoadItemArrByProductId
{
public:
	_VersionServ__QueryDownLoadItemArrByProductId *VersionServ__QueryDownLoadItemArrByProductId;	/* optional element of type VersionServ:QueryDownLoadItemArrByProductId */
public:
	int soap_type() const { return 276; } /* = unique type id SOAP_TYPE___VersionServ3__QueryDownLoadItemArrByProductId */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__GetFileHeader
#define SOAP_TYPE___VersionServ3__GetFileHeader (278)
/* Operation wrapper: */
struct __VersionServ3__GetFileHeader
{
public:
	_VersionServ__GetFileHeader *VersionServ__GetFileHeader;	/* optional element of type VersionServ:GetFileHeader */
public:
	int soap_type() const { return 278; } /* = unique type id SOAP_TYPE___VersionServ3__GetFileHeader */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__QueryObjects
#define SOAP_TYPE___VersionServ3__QueryObjects (280)
/* Operation wrapper: */
struct __VersionServ3__QueryObjects
{
public:
	_VersionServ__QueryObjects *VersionServ__QueryObjects;	/* optional element of type VersionServ:QueryObjects */
public:
	int soap_type() const { return 280; } /* = unique type id SOAP_TYPE___VersionServ3__QueryObjects */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__DownloadObjects
#define SOAP_TYPE___VersionServ3__DownloadObjects (282)
/* Operation wrapper: */
struct __VersionServ3__DownloadObjects
{
public:
	_VersionServ__DownloadObjects *VersionServ__DownloadObjects;	/* optional element of type VersionServ:DownloadObjects */
public:
	int soap_type() const { return 282; } /* = unique type id SOAP_TYPE___VersionServ3__DownloadObjects */
};
#endif

#ifndef SOAP_TYPE___VersionServ3__SaveOrUpdateObjects
#define SOAP_TYPE___VersionServ3__SaveOrUpdateObjects (284)
/* Operation wrapper: */
struct __VersionServ3__SaveOrUpdateObjects
{
public:
	_VersionServ__SaveOrUpdateObjects *VersionServ__SaveOrUpdateObjects;	/* optional element of type VersionServ:SaveOrUpdateObjects */
public:
	int soap_type() const { return 284; } /* = unique type id SOAP_TYPE___VersionServ3__SaveOrUpdateObjects */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (285)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 285; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (286)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 286; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (288)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 288; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (291)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 291; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (292)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 292; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (164)
typedef char xsd__byte;
#endif

#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (165)
typedef unsigned char xsd__unsignedByte;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
