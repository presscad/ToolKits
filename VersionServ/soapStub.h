/* soapStub.h
   Generated by gSOAP 2.8.19 from D:\Structure\VersionServTemp\VerServer.h

Copyright(C) 2000-2014, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#define SOAP_NAMESPACE_OF_ns1	"http://xerofox.com/webservices/"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20819
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (7)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfProductVersion
#define SOAP_TYPE_ns1__ArrayOfProductVersion (14)
/* ns1:ArrayOfProductVersion */
class SOAP_CMAC ns1__ArrayOfProductVersion
{
public:
	int __sizeProductVersion;	/* sequence of elements <ProductVersion> */
	class ns1__ProductVersion **ProductVersion;	/* optional element of type ns1:ProductVersion */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique type id SOAP_TYPE_ns1__ArrayOfProductVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfProductVersion() { ns1__ArrayOfProductVersion::soap_default(NULL); }
	virtual ~ns1__ArrayOfProductVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ProductVersion
#define SOAP_TYPE_ns1__ProductVersion (15)
/* ns1:ProductVersion */
class SOAP_CMAC ns1__ProductVersion
{
public:
	int id;	/* required element of type xsd:int */
	unsigned int productId;	/* required element of type xsd:unsignedInt */
	unsigned int version;	/* required element of type xsd:unsignedInt */
	time_t releaseDate;	/* required element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_ns1__ProductVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ProductVersion() { ns1__ProductVersion::soap_default(NULL); }
	virtual ~ns1__ProductVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfInt
#define SOAP_TYPE_ns1__ArrayOfInt (16)
/* ns1:ArrayOfInt */
class SOAP_CMAC ns1__ArrayOfInt
{
public:
	int __sizeint_;	/* sequence of elements <int> */
	int *int_;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_ns1__ArrayOfInt */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfInt() { ns1__ArrayOfInt::soap_default(NULL); }
	virtual ~ns1__ArrayOfInt() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfVersionRevision
#define SOAP_TYPE_ns1__ArrayOfVersionRevision (17)
/* ns1:ArrayOfVersionRevision */
class SOAP_CMAC ns1__ArrayOfVersionRevision
{
public:
	int __sizeVersionRevision;	/* sequence of elements <VersionRevision> */
	class ns1__VersionRevision **VersionRevision;	/* optional element of type ns1:VersionRevision */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique type id SOAP_TYPE_ns1__ArrayOfVersionRevision */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfVersionRevision() { ns1__ArrayOfVersionRevision::soap_default(NULL); }
	virtual ~ns1__ArrayOfVersionRevision() { }
};
#endif

#ifndef SOAP_TYPE_ns1__VersionRevision
#define SOAP_TYPE_ns1__VersionRevision (18)
/* ns1:VersionRevision */
class SOAP_CMAC ns1__VersionRevision
{
public:
	unsigned int Id;	/* required element of type xsd:unsignedInt */
	unsigned int productId;	/* required element of type xsd:unsignedInt */
	char revisionType;	/* required element of type xsd:byte */
	unsigned char important;	/* required element of type xsd:unsignedByte */
	bool readed;	/* required element of type xsd:boolean */
	char *title;	/* optional element of type xsd:string */
	char *contents;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_ns1__VersionRevision */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__VersionRevision() { ns1__VersionRevision::soap_default(NULL); }
	virtual ~ns1__VersionRevision() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ObjectV
#define SOAP_TYPE_ns1__ObjectV (20)
/* ns1:ObjectV */
class SOAP_CMAC ns1__ObjectV
{
public:
	int id;	/* required element of type xsd:int */
	char *tag;	/* optional element of type xsd:anyType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE_ns1__ObjectV */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ObjectV() { ns1__ObjectV::soap_default(NULL); }
	virtual ~ns1__ObjectV() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ArrayOfDownLoadItem
#define SOAP_TYPE_ns1__ArrayOfDownLoadItem (21)
/* ns1:ArrayOfDownLoadItem */
class SOAP_CMAC ns1__ArrayOfDownLoadItem
{
public:
	int __sizeDownLoadItem;	/* sequence of elements <DownLoadItem> */
	class ns1__DownLoadItem **DownLoadItem;	/* optional element of type ns1:DownLoadItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique type id SOAP_TYPE_ns1__ArrayOfDownLoadItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ArrayOfDownLoadItem() { ns1__ArrayOfDownLoadItem::soap_default(NULL); }
	virtual ~ns1__ArrayOfDownLoadItem() { }
};
#endif

#ifndef SOAP_TYPE__ns1__Login
#define SOAP_TYPE__ns1__Login (24)
/* ns1:Login */
class SOAP_CMAC _ns1__Login
{
public:
	xsd__base64Binary *computerMac;	/* optional element of type xsd:base64Binary */
	xsd__base64Binary *computerIp;	/* optional element of type xsd:base64Binary */
	char *computerName;	/* optional element of type xsd:string */
	unsigned int dogSerial;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE__ns1__Login */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__Login() { _ns1__Login::soap_default(NULL); }
	virtual ~_ns1__Login() { }
};
#endif

#ifndef SOAP_TYPE__ns1__LoginResponse
#define SOAP_TYPE__ns1__LoginResponse (25)
/* ns1:LoginResponse */
class SOAP_CMAC _ns1__LoginResponse
{
public:
	unsigned int LoginResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE__ns1__LoginResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__LoginResponse() { _ns1__LoginResponse::soap_default(NULL); }
	virtual ~_ns1__LoginResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__LoginByByteArr
#define SOAP_TYPE__ns1__LoginByByteArr (26)
/* ns1:LoginByByteArr */
class SOAP_CMAC _ns1__LoginByByteArr
{
public:
	xsd__base64Binary *userInfo;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE__ns1__LoginByByteArr */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__LoginByByteArr() { _ns1__LoginByByteArr::soap_default(NULL); }
	virtual ~_ns1__LoginByByteArr() { }
};
#endif

#ifndef SOAP_TYPE__ns1__LoginByByteArrResponse
#define SOAP_TYPE__ns1__LoginByByteArrResponse (27)
/* ns1:LoginByByteArrResponse */
class SOAP_CMAC _ns1__LoginByByteArrResponse
{
public:
	unsigned int LoginByByteArrResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique type id SOAP_TYPE__ns1__LoginByByteArrResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__LoginByByteArrResponse() { _ns1__LoginByByteArrResponse::soap_default(NULL); }
	virtual ~_ns1__LoginByByteArrResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetUpdateVerByCurVer
#define SOAP_TYPE__ns1__GetUpdateVerByCurVer (28)
/* ns1:GetUpdateVerByCurVer */
class SOAP_CMAC _ns1__GetUpdateVerByCurVer
{
public:
	unsigned int userId;	/* required element of type xsd:unsignedInt */
	unsigned int product_USCOREid;	/* required element of type xsd:unsignedInt */
	unsigned int uCurVersion;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE__ns1__GetUpdateVerByCurVer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetUpdateVerByCurVer() { _ns1__GetUpdateVerByCurVer::soap_default(NULL); }
	virtual ~_ns1__GetUpdateVerByCurVer() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetUpdateVerByCurVerResponse
#define SOAP_TYPE__ns1__GetUpdateVerByCurVerResponse (29)
/* ns1:GetUpdateVerByCurVerResponse */
class SOAP_CMAC _ns1__GetUpdateVerByCurVerResponse
{
public:
	ns1__ArrayOfProductVersion *GetUpdateVerByCurVerResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfProductVersion */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique type id SOAP_TYPE__ns1__GetUpdateVerByCurVerResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetUpdateVerByCurVerResponse() { _ns1__GetUpdateVerByCurVerResponse::soap_default(NULL); }
	virtual ~_ns1__GetUpdateVerByCurVerResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetRevisionReadFlag
#define SOAP_TYPE__ns1__SetRevisionReadFlag (30)
/* ns1:SetRevisionReadFlag */
class SOAP_CMAC _ns1__SetRevisionReadFlag
{
public:
	int userId;	/* required element of type xsd:int */
	ns1__ArrayOfInt *revisionIdArr;	/* optional element of type ns1:ArrayOfInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique type id SOAP_TYPE__ns1__SetRevisionReadFlag */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetRevisionReadFlag() { _ns1__SetRevisionReadFlag::soap_default(NULL); }
	virtual ~_ns1__SetRevisionReadFlag() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetRevisionReadFlagResponse
#define SOAP_TYPE__ns1__SetRevisionReadFlagResponse (31)
/* ns1:SetRevisionReadFlagResponse */
class SOAP_CMAC _ns1__SetRevisionReadFlagResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE__ns1__SetRevisionReadFlagResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetRevisionReadFlagResponse() { _ns1__SetRevisionReadFlagResponse::soap_default(NULL); }
	virtual ~_ns1__SetRevisionReadFlagResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CompareVersion
#define SOAP_TYPE__ns1__CompareVersion (32)
/* ns1:CompareVersion */
class SOAP_CMAC _ns1__CompareVersion
{
public:
	int userId;	/* required element of type xsd:int */
	unsigned int product_USCOREid;	/* required element of type xsd:unsignedInt */
	unsigned int uCurVersion;	/* required element of type xsd:unsignedInt */
	unsigned int uUpdateVersion;	/* required element of type xsd:unsignedInt */
	bool bLoadOnHasNew;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE__ns1__CompareVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CompareVersion() { _ns1__CompareVersion::soap_default(NULL); }
	virtual ~_ns1__CompareVersion() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CompareVersionResponse
#define SOAP_TYPE__ns1__CompareVersionResponse (33)
/* ns1:CompareVersionResponse */
class SOAP_CMAC _ns1__CompareVersionResponse
{
public:
	ns1__ArrayOfVersionRevision *CompareVersionResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfVersionRevision */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique type id SOAP_TYPE__ns1__CompareVersionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CompareVersionResponse() { _ns1__CompareVersionResponse::soap_default(NULL); }
	virtual ~_ns1__CompareVersionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVersionReleaseNotes
#define SOAP_TYPE__ns1__GetVersionReleaseNotes (34)
/* ns1:GetVersionReleaseNotes */
class SOAP_CMAC _ns1__GetVersionReleaseNotes
{
public:
	unsigned int product_USCOREid;	/* required element of type xsd:unsignedInt */
	unsigned int uCurVersion;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE__ns1__GetVersionReleaseNotes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVersionReleaseNotes() { _ns1__GetVersionReleaseNotes::soap_default(NULL); }
	virtual ~_ns1__GetVersionReleaseNotes() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVersionReleaseNotesResponse
#define SOAP_TYPE__ns1__GetVersionReleaseNotesResponse (35)
/* ns1:GetVersionReleaseNotesResponse */
class SOAP_CMAC _ns1__GetVersionReleaseNotesResponse
{
public:
	ns1__ArrayOfVersionRevision *GetVersionReleaseNotesResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfVersionRevision */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE__ns1__GetVersionReleaseNotesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVersionReleaseNotesResponse() { _ns1__GetVersionReleaseNotesResponse::soap_default(NULL); }
	virtual ~_ns1__GetVersionReleaseNotesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetDogAccessHistory
#define SOAP_TYPE__ns1__GetDogAccessHistory (36)
/* ns1:GetDogAccessHistory */
class SOAP_CMAC _ns1__GetDogAccessHistory
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique type id SOAP_TYPE__ns1__GetDogAccessHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetDogAccessHistory() { _ns1__GetDogAccessHistory::soap_default(NULL); }
	virtual ~_ns1__GetDogAccessHistory() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetDogAccessHistoryResponse
#define SOAP_TYPE__ns1__GetDogAccessHistoryResponse (37)
/* ns1:GetDogAccessHistoryResponse */
class SOAP_CMAC _ns1__GetDogAccessHistoryResponse
{
public:
	class ns1__DogAccessHistory *GetDogAccessHistoryResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:DogAccessHistory */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE__ns1__GetDogAccessHistoryResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetDogAccessHistoryResponse() { _ns1__GetDogAccessHistoryResponse::soap_default(NULL); }
	virtual ~_ns1__GetDogAccessHistoryResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__QueryDownLoadItemArrByProductId
#define SOAP_TYPE__ns1__QueryDownLoadItemArrByProductId (38)
/* ns1:QueryDownLoadItemArrByProductId */
class SOAP_CMAC _ns1__QueryDownLoadItemArrByProductId
{
public:
	char *dogNo;	/* optional element of type xsd:string */
	int productId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique type id SOAP_TYPE__ns1__QueryDownLoadItemArrByProductId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__QueryDownLoadItemArrByProductId() { _ns1__QueryDownLoadItemArrByProductId::soap_default(NULL); }
	virtual ~_ns1__QueryDownLoadItemArrByProductId() { }
};
#endif

#ifndef SOAP_TYPE__ns1__QueryDownLoadItemArrByProductIdResponse
#define SOAP_TYPE__ns1__QueryDownLoadItemArrByProductIdResponse (39)
/* ns1:QueryDownLoadItemArrByProductIdResponse */
class SOAP_CMAC _ns1__QueryDownLoadItemArrByProductIdResponse
{
public:
	ns1__ArrayOfDownLoadItem *QueryDownLoadItemArrByProductIdResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:ArrayOfDownLoadItem */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE__ns1__QueryDownLoadItemArrByProductIdResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__QueryDownLoadItemArrByProductIdResponse() { _ns1__QueryDownLoadItemArrByProductIdResponse::soap_default(NULL); }
	virtual ~_ns1__QueryDownLoadItemArrByProductIdResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetFileHeader
#define SOAP_TYPE__ns1__GetFileHeader (40)
/* ns1:GetFileHeader */
class SOAP_CMAC _ns1__GetFileHeader
{
public:
	int downLoadItemId;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE__ns1__GetFileHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetFileHeader() { _ns1__GetFileHeader::soap_default(NULL); }
	virtual ~_ns1__GetFileHeader() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetFileHeaderResponse
#define SOAP_TYPE__ns1__GetFileHeaderResponse (41)
/* ns1:GetFileHeaderResponse */
class SOAP_CMAC _ns1__GetFileHeaderResponse
{
public:
	class ns1__FileHeader *GetFileHeaderResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns1:FileHeader */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique type id SOAP_TYPE__ns1__GetFileHeaderResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetFileHeaderResponse() { _ns1__GetFileHeaderResponse::soap_default(NULL); }
	virtual ~_ns1__GetFileHeaderResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__QueryObjects
#define SOAP_TYPE__ns1__QueryObjects (42)
/* ns1:QueryObjects */
class SOAP_CMAC _ns1__QueryObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	char *xmlScope;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE__ns1__QueryObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__QueryObjects() { _ns1__QueryObjects::soap_default(NULL); }
	virtual ~_ns1__QueryObjects() { }
};
#endif

#ifndef SOAP_TYPE__ns1__QueryObjectsResponse
#define SOAP_TYPE__ns1__QueryObjectsResponse (43)
/* ns1:QueryObjectsResponse */
class SOAP_CMAC _ns1__QueryObjectsResponse
{
public:
	xsd__base64Binary *QueryObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE__ns1__QueryObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__QueryObjectsResponse() { _ns1__QueryObjectsResponse::soap_default(NULL); }
	virtual ~_ns1__QueryObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DownloadObjects
#define SOAP_TYPE__ns1__DownloadObjects (44)
/* ns1:DownloadObjects */
class SOAP_CMAC _ns1__DownloadObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	ns1__ArrayOfInt *idarr;	/* optional element of type ns1:ArrayOfInt */
	unsigned int serialize;	/* required element of type xsd:unsignedInt */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique type id SOAP_TYPE__ns1__DownloadObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DownloadObjects() { _ns1__DownloadObjects::soap_default(NULL); }
	virtual ~_ns1__DownloadObjects() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DownloadObjectsResponse
#define SOAP_TYPE__ns1__DownloadObjectsResponse (45)
/* ns1:DownloadObjectsResponse */
class SOAP_CMAC _ns1__DownloadObjectsResponse
{
public:
	xsd__base64Binary *DownloadObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique type id SOAP_TYPE__ns1__DownloadObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DownloadObjectsResponse() { _ns1__DownloadObjectsResponse::soap_default(NULL); }
	virtual ~_ns1__DownloadObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SaveOrUpdateObjects
#define SOAP_TYPE__ns1__SaveOrUpdateObjects (46)
/* ns1:SaveOrUpdateObjects */
class SOAP_CMAC _ns1__SaveOrUpdateObjects
{
public:
	int sessionId;	/* required element of type xsd:int */
	char *clsName;	/* optional element of type xsd:string */
	char *xmlformat;	/* optional element of type xsd:string */
	xsd__base64Binary *byteArr;	/* optional element of type xsd:base64Binary */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique type id SOAP_TYPE__ns1__SaveOrUpdateObjects */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SaveOrUpdateObjects() { _ns1__SaveOrUpdateObjects::soap_default(NULL); }
	virtual ~_ns1__SaveOrUpdateObjects() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SaveOrUpdateObjectsResponse
#define SOAP_TYPE__ns1__SaveOrUpdateObjectsResponse (47)
/* ns1:SaveOrUpdateObjectsResponse */
class SOAP_CMAC _ns1__SaveOrUpdateObjectsResponse
{
public:
	char *SaveOrUpdateObjectsResult;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE__ns1__SaveOrUpdateObjectsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SaveOrUpdateObjectsResponse() { _ns1__SaveOrUpdateObjectsResponse::soap_default(NULL); }
	virtual ~_ns1__SaveOrUpdateObjectsResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DogAccessHistory
#define SOAP_TYPE_ns1__DogAccessHistory (19)
/* ns1:DogAccessHistory */
class SOAP_CMAC ns1__DogAccessHistory : public ns1__ObjectV
{
public:
	char *dogserial;	/* optional element of type xsd:string */
	int endUserId;	/* required element of type xsd:int */
	int productId;	/* required element of type xsd:int */
	int cycleSerial;	/* required element of type xsd:int */
	int accessType;	/* required element of type xsd:int */
	int accessOccurDate;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_ns1__DogAccessHistory */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DogAccessHistory() { ns1__DogAccessHistory::soap_default(NULL); }
	virtual ~ns1__DogAccessHistory() { }
};
#endif

#ifndef SOAP_TYPE_ns1__DownLoadItem
#define SOAP_TYPE_ns1__DownLoadItem (22)
/* ns1:DownLoadItem */
class SOAP_CMAC ns1__DownLoadItem : public ns1__ObjectV
{
public:
	char *title;	/* optional element of type xsd:string */
	time_t updateDate;	/* required element of type xsd:dateTime */
	char *notes;	/* optional element of type xsd:string */
	int serialno;	/* required element of type xsd:int */
	char *occurDateValue;	/* optional element of type xsd:string */
	char *fileName;	/* optional element of type xsd:string */
	int productId;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_ns1__DownLoadItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__DownLoadItem() { ns1__DownLoadItem::soap_default(NULL); }
	virtual ~ns1__DownLoadItem() { }
};
#endif

#ifndef SOAP_TYPE_ns1__FileHeader
#define SOAP_TYPE_ns1__FileHeader (23)
/* ns1:FileHeader */
class SOAP_CMAC ns1__FileHeader : public ns1__ObjectV
{
public:
	char *filePath;	/* optional element of type xsd:string */
	int fileType;	/* required element of type xsd:int */
	char *fileName;	/* optional element of type xsd:string */
	char *fileNameServer;	/* optional element of type xsd:string */
	int hostId;	/* required element of type xsd:int */
	int ownerId;	/* required element of type xsd:int */
	xsd__base64Binary *matter;	/* optional element of type xsd:base64Binary */
	char *description;	/* optional element of type xsd:string */
	time_t occurDateValue;	/* required element of type xsd:dateTime */
	int serialNo;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_ns1__FileHeader */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__FileHeader() { ns1__FileHeader::soap_default(NULL); }
	virtual ~ns1__FileHeader() { }
};
#endif

#ifndef SOAP_TYPE___ns1__Login
#define SOAP_TYPE___ns1__Login (67)
/* Operation wrapper: */
struct __ns1__Login
{
public:
	_ns1__Login *ns1__Login;	/* optional element of type ns1:Login */
public:
	int soap_type() const { return 67; } /* = unique type id SOAP_TYPE___ns1__Login */
};
#endif

#ifndef SOAP_TYPE___ns1__LoginByByteArr
#define SOAP_TYPE___ns1__LoginByByteArr (71)
/* Operation wrapper: */
struct __ns1__LoginByByteArr
{
public:
	_ns1__LoginByByteArr *ns1__LoginByByteArr;	/* optional element of type ns1:LoginByByteArr */
public:
	int soap_type() const { return 71; } /* = unique type id SOAP_TYPE___ns1__LoginByByteArr */
};
#endif

#ifndef SOAP_TYPE___ns1__GetUpdateVerByCurVer
#define SOAP_TYPE___ns1__GetUpdateVerByCurVer (75)
/* Operation wrapper: */
struct __ns1__GetUpdateVerByCurVer
{
public:
	_ns1__GetUpdateVerByCurVer *ns1__GetUpdateVerByCurVer;	/* optional element of type ns1:GetUpdateVerByCurVer */
public:
	int soap_type() const { return 75; } /* = unique type id SOAP_TYPE___ns1__GetUpdateVerByCurVer */
};
#endif

#ifndef SOAP_TYPE___ns1__SetRevisionReadFlag
#define SOAP_TYPE___ns1__SetRevisionReadFlag (79)
/* Operation wrapper: */
struct __ns1__SetRevisionReadFlag
{
public:
	_ns1__SetRevisionReadFlag *ns1__SetRevisionReadFlag;	/* optional element of type ns1:SetRevisionReadFlag */
public:
	int soap_type() const { return 79; } /* = unique type id SOAP_TYPE___ns1__SetRevisionReadFlag */
};
#endif

#ifndef SOAP_TYPE___ns1__CompareVersion
#define SOAP_TYPE___ns1__CompareVersion (83)
/* Operation wrapper: */
struct __ns1__CompareVersion
{
public:
	_ns1__CompareVersion *ns1__CompareVersion;	/* optional element of type ns1:CompareVersion */
public:
	int soap_type() const { return 83; } /* = unique type id SOAP_TYPE___ns1__CompareVersion */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVersionReleaseNotes
#define SOAP_TYPE___ns1__GetVersionReleaseNotes (87)
/* Operation wrapper: */
struct __ns1__GetVersionReleaseNotes
{
public:
	_ns1__GetVersionReleaseNotes *ns1__GetVersionReleaseNotes;	/* optional element of type ns1:GetVersionReleaseNotes */
public:
	int soap_type() const { return 87; } /* = unique type id SOAP_TYPE___ns1__GetVersionReleaseNotes */
};
#endif

#ifndef SOAP_TYPE___ns1__GetDogAccessHistory
#define SOAP_TYPE___ns1__GetDogAccessHistory (91)
/* Operation wrapper: */
struct __ns1__GetDogAccessHistory
{
public:
	_ns1__GetDogAccessHistory *ns1__GetDogAccessHistory;	/* optional element of type ns1:GetDogAccessHistory */
public:
	int soap_type() const { return 91; } /* = unique type id SOAP_TYPE___ns1__GetDogAccessHistory */
};
#endif

#ifndef SOAP_TYPE___ns1__QueryDownLoadItemArrByProductId
#define SOAP_TYPE___ns1__QueryDownLoadItemArrByProductId (95)
/* Operation wrapper: */
struct __ns1__QueryDownLoadItemArrByProductId
{
public:
	_ns1__QueryDownLoadItemArrByProductId *ns1__QueryDownLoadItemArrByProductId;	/* optional element of type ns1:QueryDownLoadItemArrByProductId */
public:
	int soap_type() const { return 95; } /* = unique type id SOAP_TYPE___ns1__QueryDownLoadItemArrByProductId */
};
#endif

#ifndef SOAP_TYPE___ns1__GetFileHeader
#define SOAP_TYPE___ns1__GetFileHeader (99)
/* Operation wrapper: */
struct __ns1__GetFileHeader
{
public:
	_ns1__GetFileHeader *ns1__GetFileHeader;	/* optional element of type ns1:GetFileHeader */
public:
	int soap_type() const { return 99; } /* = unique type id SOAP_TYPE___ns1__GetFileHeader */
};
#endif

#ifndef SOAP_TYPE___ns1__QueryObjects
#define SOAP_TYPE___ns1__QueryObjects (103)
/* Operation wrapper: */
struct __ns1__QueryObjects
{
public:
	_ns1__QueryObjects *ns1__QueryObjects;	/* optional element of type ns1:QueryObjects */
public:
	int soap_type() const { return 103; } /* = unique type id SOAP_TYPE___ns1__QueryObjects */
};
#endif

#ifndef SOAP_TYPE___ns1__DownloadObjects
#define SOAP_TYPE___ns1__DownloadObjects (107)
/* Operation wrapper: */
struct __ns1__DownloadObjects
{
public:
	_ns1__DownloadObjects *ns1__DownloadObjects;	/* optional element of type ns1:DownloadObjects */
public:
	int soap_type() const { return 107; } /* = unique type id SOAP_TYPE___ns1__DownloadObjects */
};
#endif

#ifndef SOAP_TYPE___ns1__SaveOrUpdateObjects
#define SOAP_TYPE___ns1__SaveOrUpdateObjects (111)
/* Operation wrapper: */
struct __ns1__SaveOrUpdateObjects
{
public:
	_ns1__SaveOrUpdateObjects *ns1__SaveOrUpdateObjects;	/* optional element of type ns1:SaveOrUpdateObjects */
public:
	int soap_type() const { return 111; } /* = unique type id SOAP_TYPE___ns1__SaveOrUpdateObjects */
};
#endif

#ifndef SOAP_TYPE___ns1__Login_
#define SOAP_TYPE___ns1__Login_ (113)
/* Operation wrapper: */
struct __ns1__Login_
{
public:
	_ns1__Login *ns1__Login;	/* optional element of type ns1:Login */
public:
	int soap_type() const { return 113; } /* = unique type id SOAP_TYPE___ns1__Login_ */
};
#endif

#ifndef SOAP_TYPE___ns1__LoginByByteArr_
#define SOAP_TYPE___ns1__LoginByByteArr_ (115)
/* Operation wrapper: */
struct __ns1__LoginByByteArr_
{
public:
	_ns1__LoginByByteArr *ns1__LoginByByteArr;	/* optional element of type ns1:LoginByByteArr */
public:
	int soap_type() const { return 115; } /* = unique type id SOAP_TYPE___ns1__LoginByByteArr_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetUpdateVerByCurVer_
#define SOAP_TYPE___ns1__GetUpdateVerByCurVer_ (117)
/* Operation wrapper: */
struct __ns1__GetUpdateVerByCurVer_
{
public:
	_ns1__GetUpdateVerByCurVer *ns1__GetUpdateVerByCurVer;	/* optional element of type ns1:GetUpdateVerByCurVer */
public:
	int soap_type() const { return 117; } /* = unique type id SOAP_TYPE___ns1__GetUpdateVerByCurVer_ */
};
#endif

#ifndef SOAP_TYPE___ns1__SetRevisionReadFlag_
#define SOAP_TYPE___ns1__SetRevisionReadFlag_ (119)
/* Operation wrapper: */
struct __ns1__SetRevisionReadFlag_
{
public:
	_ns1__SetRevisionReadFlag *ns1__SetRevisionReadFlag;	/* optional element of type ns1:SetRevisionReadFlag */
public:
	int soap_type() const { return 119; } /* = unique type id SOAP_TYPE___ns1__SetRevisionReadFlag_ */
};
#endif

#ifndef SOAP_TYPE___ns1__CompareVersion_
#define SOAP_TYPE___ns1__CompareVersion_ (121)
/* Operation wrapper: */
struct __ns1__CompareVersion_
{
public:
	_ns1__CompareVersion *ns1__CompareVersion;	/* optional element of type ns1:CompareVersion */
public:
	int soap_type() const { return 121; } /* = unique type id SOAP_TYPE___ns1__CompareVersion_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVersionReleaseNotes_
#define SOAP_TYPE___ns1__GetVersionReleaseNotes_ (123)
/* Operation wrapper: */
struct __ns1__GetVersionReleaseNotes_
{
public:
	_ns1__GetVersionReleaseNotes *ns1__GetVersionReleaseNotes;	/* optional element of type ns1:GetVersionReleaseNotes */
public:
	int soap_type() const { return 123; } /* = unique type id SOAP_TYPE___ns1__GetVersionReleaseNotes_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetDogAccessHistory_
#define SOAP_TYPE___ns1__GetDogAccessHistory_ (125)
/* Operation wrapper: */
struct __ns1__GetDogAccessHistory_
{
public:
	_ns1__GetDogAccessHistory *ns1__GetDogAccessHistory;	/* optional element of type ns1:GetDogAccessHistory */
public:
	int soap_type() const { return 125; } /* = unique type id SOAP_TYPE___ns1__GetDogAccessHistory_ */
};
#endif

#ifndef SOAP_TYPE___ns1__QueryDownLoadItemArrByProductId_
#define SOAP_TYPE___ns1__QueryDownLoadItemArrByProductId_ (127)
/* Operation wrapper: */
struct __ns1__QueryDownLoadItemArrByProductId_
{
public:
	_ns1__QueryDownLoadItemArrByProductId *ns1__QueryDownLoadItemArrByProductId;	/* optional element of type ns1:QueryDownLoadItemArrByProductId */
public:
	int soap_type() const { return 127; } /* = unique type id SOAP_TYPE___ns1__QueryDownLoadItemArrByProductId_ */
};
#endif

#ifndef SOAP_TYPE___ns1__GetFileHeader_
#define SOAP_TYPE___ns1__GetFileHeader_ (129)
/* Operation wrapper: */
struct __ns1__GetFileHeader_
{
public:
	_ns1__GetFileHeader *ns1__GetFileHeader;	/* optional element of type ns1:GetFileHeader */
public:
	int soap_type() const { return 129; } /* = unique type id SOAP_TYPE___ns1__GetFileHeader_ */
};
#endif

#ifndef SOAP_TYPE___ns1__QueryObjects_
#define SOAP_TYPE___ns1__QueryObjects_ (131)
/* Operation wrapper: */
struct __ns1__QueryObjects_
{
public:
	_ns1__QueryObjects *ns1__QueryObjects;	/* optional element of type ns1:QueryObjects */
public:
	int soap_type() const { return 131; } /* = unique type id SOAP_TYPE___ns1__QueryObjects_ */
};
#endif

#ifndef SOAP_TYPE___ns1__DownloadObjects_
#define SOAP_TYPE___ns1__DownloadObjects_ (133)
/* Operation wrapper: */
struct __ns1__DownloadObjects_
{
public:
	_ns1__DownloadObjects *ns1__DownloadObjects;	/* optional element of type ns1:DownloadObjects */
public:
	int soap_type() const { return 133; } /* = unique type id SOAP_TYPE___ns1__DownloadObjects_ */
};
#endif

#ifndef SOAP_TYPE___ns1__SaveOrUpdateObjects_
#define SOAP_TYPE___ns1__SaveOrUpdateObjects_ (135)
/* Operation wrapper: */
struct __ns1__SaveOrUpdateObjects_
{
public:
	_ns1__SaveOrUpdateObjects *ns1__SaveOrUpdateObjects;	/* optional element of type ns1:SaveOrUpdateObjects */
public:
	int soap_type() const { return 135; } /* = unique type id SOAP_TYPE___ns1__SaveOrUpdateObjects_ */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (136)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 136; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (137)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 137; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (139)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 139; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (142)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 142; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (143)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 143; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_xsd__byte
#define SOAP_TYPE_xsd__byte (12)
typedef char xsd__byte;
#endif

#ifndef SOAP_TYPE_xsd__unsignedByte
#define SOAP_TYPE_xsd__unsignedByte (13)
typedef unsigned char xsd__unsignedByte;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
